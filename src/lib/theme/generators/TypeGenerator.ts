/**
 * TypeScript Type Generator
 * 
 * Generates TypeScript type definitions from theme objects
 */

import type { Theme } from '../types';

/**
 * Type generation options
 */
export interface TypeGeneratorOptions {
  /** Module name for generated types */
  moduleName?: string;
  /** Include JSDoc comments */
  includeComments?: boolean;
  /** Export style */
  exportStyle?: 'named' | 'default' | 'both';
  /** Include theme interface augmentation */
  includeAugmentation?: boolean;
}

/**
 * TypeScript Type Generator
 * 
 * Generates TypeScript definitions for theme objects
 */
export class TypeGenerator {
  private options: Required<TypeGeneratorOptions>;

  constructor(options: TypeGeneratorOptions = {}) {
    this.options = {
      moduleName: options.moduleName || 'Theme',
      includeComments: options.includeComments ?? true,
      exportStyle: options.exportStyle || 'named',
      includeAugmentation: options.includeAugmentation ?? false,
    };
  }

  /**
   * Generate TypeScript definitions from theme
   */
  generate(theme: Theme): string {
    let output = '';

    if (this.options.includeComments) {
      output += this.generateHeader();
    }

    output += this.generateImports();
    output += this.generateThemeInterface(theme);

    if (this.options.includeAugmentation) {
      output += this.generateAugmentation();
    }

    return output;
  }

  /**
   * Generate file header
   */
  private generateHeader(): string {
    return `/**
 * Generated Theme Types
 * 
 * Auto-generated TypeScript definitions for ${this.options.moduleName}
 * Do not edit this file directly.
 */

`;
  }

  /**
   * Generate imports
   */
  private generateImports(): string {
    return `import type { Theme as BaseTheme } from '@shohojdhara/atomix/theme';

`;
  }

  /**
   * Generate theme interface
   */
  private generateThemeInterface(theme: Theme): string {
    let output = '';

    if (this.options.includeComments) {
      output += `/**
 * ${theme.name || 'Custom'} Theme Interface
 */
`;
    }

    output += `export interface ${this.options.moduleName} extends BaseTheme {\n`;
    output += `  name: '${theme.name}';\n`;
    
    if (theme.class) {
      output += `  class: '${theme.class}';\n`;
    }

    // Generate palette types
    output += this.generatePaletteTypes(theme.palette);

    // Generate typography types
    output += this.generateTypographyTypes(theme.typography);

    // Generate custom properties if any
    if (Object.keys(theme.custom).length > 0) {
      output += this.generateCustomTypes(theme.custom);
    }

    output += '}\n\n';

    // Generate exports
    if (this.options.exportStyle === 'default' || this.options.exportStyle === 'both') {
      output += `declare const theme: ${this.options.moduleName};\n`;
      output += `export default theme;\n\n`;
    }

    if (this.options.exportStyle === 'named' || this.options.exportStyle === 'both') {
      output += `export type { ${this.options.moduleName} };\n`;
    }

    return output;
  }

  /**
   * Generate palette types
   */
  private generatePaletteTypes(palette: Theme['palette']): string {
    let output = '  palette: {\n';

    const colors = ['primary', 'secondary', 'error', 'warning', 'info', 'success'] as const;
    for (const color of colors) {
      const colorObj = palette[color];
      if (colorObj) {
        output += `    ${color}: {\n`;
        output += `      main: '${colorObj.main}';\n`;
        if (colorObj.light) output += `      light: '${colorObj.light}';\n`;
        if (colorObj.dark) output += `      dark: '${colorObj.dark}';\n`;
        if (colorObj.contrastText) output += `      contrastText: '${colorObj.contrastText}';\n`;
        output += '    };\n';
      }
    }

    // Background
    if (palette.background) {
      output += '    background: {\n';
      output += `      default: '${palette.background.default}';\n`;
      output += `      paper: '${palette.background.paper}';\n`;
      output += `      subtle: '${palette.background.subtle}';\n`;
      output += '    };\n';
    }

    // Text
    if (palette.text) {
      output += '    text: {\n';
      output += `      primary: '${palette.text.primary}';\n`;
      output += `      secondary: '${palette.text.secondary}';\n`;
      output += `      disabled: '${palette.text.disabled}';\n`;
      output += '    };\n';
    }

    output += '  };\n';
    return output;
  }

  /**
   * Generate typography types
   */
  private generateTypographyTypes(typography: Theme['typography']): string {
    let output = '  typography: {\n';
    output += `    fontFamily: '${typography.fontFamily}';\n`;
    output += `    fontSize: ${typography.fontSize};\n`;

    // Font weights
    if (typography.fontWeightLight) output += `    fontWeightLight: ${typography.fontWeightLight};\n`;
    if (typography.fontWeightRegular) output += `    fontWeightRegular: ${typography.fontWeightRegular};\n`;
    if (typography.fontWeightMedium) output += `    fontWeightMedium: ${typography.fontWeightMedium};\n`;
    if (typography.fontWeightSemiBold) output += `    fontWeightSemiBold: ${typography.fontWeightSemiBold};\n`;
    if (typography.fontWeightBold) output += `    fontWeightBold: ${typography.fontWeightBold};\n`;

    output += '  };\n';
    return output;
  }

  /**
   * Generate custom property types
   */
  private generateCustomTypes(custom: Theme['custom']): string {
    let output = '  custom: {\n';

    for (const [key, value] of Object.entries(custom)) {
      const type = typeof value === 'string' ? `'${value}'` : typeof value;
      output += `    ${key}: ${type};\n`;
    }

    output += '  };\n';
    return output;
  }

  /**
   * Generate module augmentation
   */
  private generateAugmentation(): string {
    return `
declare module '@shohojdhara/atomix/theme' {
  interface ThemeCustomProperties {
    ${this.options.moduleName}: ${this.options.moduleName};
  }
}
`;
  }
}

/**
 * Generate TypeScript types from theme
 * 
 * @param theme - Theme object
 * @param options - Generation options
 * @returns TypeScript definition string
 */
export function generateTypes(theme: Theme, options: TypeGeneratorOptions = {}): string {
  const generator = new TypeGenerator(options);
  return generator.generate(theme);
}